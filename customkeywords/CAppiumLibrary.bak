#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Created on 2015年7月21日

@author: zhang.xiuhai
'''

from  robot.api import logger
import os
import re
import subprocess
import smtplib,sys,email
from sys import stderr
import string,random
import shutil,filecmp
from random import choice 
import hashlib

from twisted.internet.protocol import ServerFactory, ProcessProtocol
from twisted.protocols.basic import LineReceiver
from twisted.python import log
from twisted.internet import reactor, threads

MAXVERSIONS = 100 

class CAppiumLibrary(object):
    '''
    classdocs
    '''

    def __init__(self):
        '''
        Constructor
        '''
    
    def get_local_address(self):    
        u'''获取本地的地址.例
        
        '''
        tmpconfig = os.popen('ipconfig').read()
        ip = re.search(r'192.168.*.*', tmpconfig)
        return ip.group(0)
    
    def launch_appium(self, ip, tport, mode):
        u'''根据ip，port，mode启动本地appium，例           
        
        '''
        launchCMD = "appium.cmd -a " + ip + " -p " + tport + " " + "--" + mode
        child = subprocess.Popen(launchCMD, shell=True)
        return child.pid

    def stop_appium(self, pid):
        u'''停止测试工具Appium
        '''
        stopAppiumCMD = "tskill " +str(pid)
        os.system(stopAppiumCMD)
        
    def get_port_pid(self, port):   
        u'''根据参数中的端口号查找对应使用该端口号的进程ID，
                        并返回该进程的PID号。
        '''
        getPidCMD = "netstat -ano | findstr " + port
        appiumPidStr = os.popen(getPidCMD).read()

        if appiumPidStr:
            appiumG = appiumPidStr.split(' ')
            return appiumG[-1]
            logger.console("process about port " + port +" is "+appiumG[-1]+" .", True, 'stdout')
        else:
            logger.console("No process about port " + port +"!", True, 'stdout')
        
    def set_androidlog_status(self, flag=False, mode=True):
        u'''设置android日志开关
        '''
        srchAdbCMD = "tasklist | findstr adb"
        logPid = self.get_CMD_pid('adb.exe')
        
        if mode == True:
            logCMD = "adb shell logcat -v time >D:\Logs\logcat_" + flag + ".log &1"
            subprocess.Popen(logCMD, shell=True)
        elif mode == False:
            for i in logPid:
                logoffCMD = "tskill " + i
                child = subprocess.Popen(logoffCMD, shell=True)
                child.wait()
        else:
            return -1
        
        logger.debug("Debug on.", html=True)
        
    def grap_androidLog_afterOper(self, flag, path):  
        u'''获取操作后日志
        
        '''
        os.system("adb logcat -v time -d > "+path+"log_" + flag + ".log &1")
    
    
    def get_CMD_pid(self, tcmd):
        u'''获取执行命令的进程ID
        
        '''
        srchAdbCMD = "tasklist | findstr adb.exe"
        rStr = os.popen(srchAdbCMD).read()
        rg = rStr.split(' ')
        pidList = []
        num = 0
        for i in rg:
            if re.search(tcmd, i):
                num = num + 1
            elif re.match(r'\d{5}|\d{4}', i):
                pidList.append(i)
            else:
                pass
            
        if num <= 1 :
            logger.console("The process about "+ tcmd +" is not exist.", True)
        else:
            return pidList[1:num]
    
    def kill_adb_process(self, proAlias):
        u'''杀掉移动端指定包名的进程
        '''
        adbCmd = "adb shell ps | grep "+proAlias+" | grep -v ecmapplication:"
        proDetails = os.popen(adbCmd).read()
#         print proDetails
        isNull = (len(proDetails)==0)
        
        if isNull:
            print proAlias +" is not alive."
            return;
        else: 
            adbPid = proDetails.split(' ')
#             print adbPid
            retVal = os.system("adb shell kill "+ str(adbPid[4]))
            
            if retVal == 0:
                print proAlias + " "+ str(adbPid[4]) + " killed successfully."
            else:
                print proAlias + " "+ str(adbPid[4]) + " process fail to kill!"
        
    def Cswipe(self, xstart, ystart, xend, yend):
        u'''自定义滑动屏幕关键字
        '''  
        os.system("adb shell input swipe "+str(xstart)+" "+str(ystart)+" " +str(xend)+" "+str(yend))
        return 0  
    
    def run_all_bat(self,path):
        u'''接收一个目录的路径，并执行目录下的所有bat文件.例
         | run all bat                   | filepath                 | 
        '''
        for root,dirs,files in os.walk(path):
            for f in files:
                if os.path.splitext(f)[1] == '.bat':
                    os.chdir(root)
                    #print root,f
                    os.system(f)

    def __execute_sql(self, path):
        logger.debug("Executing : %s" % path)
        print path

    def decode(self,customerstr):
        return customerstr.decode('utf-8')
    
#     def sendEmail():
#         result_name = []
#         mail_from = ""
#         mail_to = ['', '']
#         msg = MIMEText(result_name[0],_subtype='plain',_charset='utf-8') 
#         msg['Subject']='web自动化测试报告'
#         smtp=smtplib.SMTP('smtp.office365.com',587) smtp.ehlo() smtp.starttls()     #用户名密码 
#         smtp.login("发邮件用的邮箱地址","发邮件用的邮箱密码") smtp.sendmail(mail_from,mail_to,msg.as_string())
#         smtp.sendmail(mail_from,mail_to,msg.as_string()) 
#         smtp.quit()

'''
pn1: 生成随机密码
'''  
def GenPasswd(length = 8,chars = string.letters+string.digits):  
    return ''.join([choice(chars) for i in range(length)])  

'''
pn2: 生成易记的伪随机密码:
（1）对于每一个随机字符，我们都按照以下流程处理一遍

（2）随机找到中间点，然后分成两段，翻转合并

（3）用最后的结果的倒数maxmem个字符来做locate标记

（4）每次找到这个locate处，若找不到，locate缩减为locate[1:]，继续找，直到找到为止

（5）我们要的本次的随机字符就是找到的locate处的后一个字符self.data[where+len(locate)+1]，如果locate为空，那么ch就是（2）后的第一个字符，也是随机的
'''
class password(object):  
    def __init__(self,filename):  
        self.data = open(filename).read().lower()  
    def renew(self,n = 8,maxmem = 3):  
        chars = []  
        for i in range(n):  
            rmdIndex = random.randrange(len(self.data))   
            self.data = self.data[rmdIndex:]+self.data[:rmdIndex]  
            where = -1  
            locate = chars[-maxmem:]  
            while where < 0 and locate:  
                where = self.data.find(str(locate))  
                locate = locate[1:]  
            ch = self.data[where+len(locate)+1]  
            if not ch.islower():  
                ch = random.choice(string.lowercase)  
            chars.append(ch)  
        return ''.join(chars)    

'''
pn3:统计Apache中每个IP的点击率
思想：
（1）按行读内容，正则匹配
（2）检查IP范围，min 和 max 的妙用
（3）存在+1，不存在置1：list[ip] = list.get(ip,0) + 1，这里的get中的0是指获取不到ip的时候的默认值
'''
def calcuteApacheIpHits(logfile_pathname):  
    ip_specs = r'\.'.join([r'\d{1,3}']*4)  
    re_ip = re.compile(ip_specs)  
  
    ipHitListing = {}  
    contents = open(logfile_pathname,"r")  
    for line in contents:  
        match = re_ip.match(line)  
        if match :  
            ip = match.group()  
            #检查正确性  
            try:  
                quad = map(int,ip.split('.'))  
            except ValueError:  
                pass  
            else:  
                #如果ip存在就+1，不存在就设置为1  
                if len(quad) == 4 and min(quad) >= 0 and max(quad) <= 255:   
                    ipHitListing[ip] = ipHitListing.get(ip,0) + 1  
    return ipHitListing

'''
备份文件
''' 
def backup(tree_top,bakdir_name = 'bakdir'):  
    for root,subdirs,files in os.walk(tree_top):  
        #join链接出每个root下的子目录bakdir  
        backup_dir = os.path.join(root,bakdir_name)  
        #确保每个root下都有个子目录叫bakdir  
        if not os.path.exists(backup_dir):  
            os.makedirs(backup_dir)  
        #bakdir下的不递归处理  
        subdirs[:] = [d for d in subdirs if d != bakdir_name]  
  
        for file in files:  
            filepath = os.path.join(root,file)  
            destpath = os.path.join(backup_dir,file)  
            #检查版本，共有MAXVERSIONS个版本  
            for index in xrange(MAXVERSIONS):  
                backup = "%s.%2.2d" % (destpath,index)  
                if not os.path.exists(backup):  
                    break  
            if index > 0:  
                old_backup = "%s.%2.2d" % (destpath,index-1)  
                #abspath = os.path.abspath(filepath)#filepath本来就是绝对路径  
                try:  
                    #如果备份和源文件一致，continue不处理  
                    if os.path.isfile(old_backup) and filecmp.cmp(filepath,old_backup,shallow = False):  
                        continue  
                except OSError:  
                        pass  
            try:  
                shutil.copy(filepath,backup)  
            except OSError:  
                pass

'''
事件驱动
'''            
class TailProtocol(ProcessProtocol):
    def __init__(self, write_callback):
        self.write = write_callback

    def outReceived(self, data):
        self.write("Begin lastlog\n")
        data = [line for line in data.split('\n') if not line.startswith('==')]
        for d in data:
            self.write(d + '\n')
        self.write("End lastlog\n")

    def processEnded(self, reason):
        if reason.value.exitCode != 0:
            log.msg(reason)

class HashCompute(object):
    def __init__(self, path, write_callback):
        self.path = path
        self.write = write_callback

    def blockingMethod(self):
        os.path.isfile(self.path)
        data = file(self.path).read()
        # uncomment to add more delay
        # import time
        # time.sleep(10)
        return hashlib.sha1(data).hexdigest()

    def compute(self):
        d = threads.deferToThread(self.blockingMethod)
        d.addCallback(self.ret)
        d.addErrback(self.err)

    def ret(self, hdata):
        self.write("File hash is : %s\n" % hdata)

    def err(self, failure):
        self.write("An error occured : %s\n" % failure.getErrorMessage())

class CmdProtocol(LineReceiver):

    delimiter = '\n'

    def processCmd(self, line):
        if line.startswith('lastlog'):
            tailProtocol = TailProtocol(self.transport.write)
#             reactor.spawnProcess(tailProtocol, '/usr/bin/tail', args=['/usr/bin/tail', '-10', '/var/log/syslog'])
        elif line.startswith('comphash'):
            try:
                useless, path = line.split(' ')
            except:
                self.transport.write('Please provide a path.\n')
                return
            hc = HashCompute(path, self.transport.write)
            hc.compute()
        elif line.startswith('exit'):
            self.transport.loseConnection()
        else:
            self.transport.write('Command not found.\n')

    def connectionMade(self):
        self.client_ip = self.transport.getPeer()[1]
        log.msg("Client connection from %s" % self.client_ip)
        if len(self.factory.clients) >= self.factory.clients_max:
            log.msg("Too many connections. bye !")
            self.client_ip = None
            self.transport.loseConnection()
        else:
            self.factory.clients.append(self.client_ip)

    def connectionLost(self, reason):
        log.msg('Lost client connection.  Reason: %s' % reason)
        if self.client_ip:
            self.factory.clients.remove(self.client_ip)

    def lineReceived(self, line):
        log.msg('Cmd received from %s : %s' % (self.client_ip, line))
        self.processCmd(line)

class MyFactory(ServerFactory):

    protocol = CmdProtocol

    def __init__(self, clients_max=10):
        self.clients_max = clients_max
        self.clients = []          

if __name__ == '__main__':
    tmpObject = CAppiumLibrary()
    tmpObject.kill_adb_process('ecm')
#     tmpObject.Cswipe(250, 0, 250, 500)
#     tmpObject.set_androidlog_status('test1', True)
#     tpidList =  tmpObject.get_CMD_pid('adb.exe')
    tmpObject.set_androidlog_status('test729343434322', True)
#     tmpObject.set_androidlog_status(False, False)
    
#     tmpPid = tmpObject.get_port_pid('4723')
    tmpIp = tmpObject.get_local_address()
    
    #tmpPid = tmpObject.launch_appium(tmpIp, '4723', "no-reset")
#     print tmpPid
    
#     if tmpPid:
#         tmpObject.stop_appium(tmpPid)
#         print "stop appium."
#     else:
#         pass
# log.startLogging(sys.stdout)
# reactor.listenTCP(9999, MyFactory(2))
# reactor.run()