
#include "general.h"
#include "Encrypt.h"
#include "Utils_c.h"
#include "Encrypt.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include"ErrorTest.h"
#include <stdlib.h>
#include <stdio.h>
#include "vendor.h"




//Set all buffer data to zero
#define BUFFER_REFRESH_ZERO(data1,data1len,data2,data2len)\
	do\
{\
	data1len = sizeof(data1);\
	memset(data1, 0, data1len);\
	data2len=sizeof(data2);\
	memset(data2, 0, data2len);\
}while(0)

bool xtest_ZUCPerformance_modify(int loopTime, int datalen, const char* pcZucFile, int threshold)
{
	bool bRtn = false;
	//string temp;
	char strtemp[256];
	CK_RV rv=0;
	CK_OBJECT_CLASS keyClass = CKO_SECRET_KEY;
	CK_BBOOL ttrue = CK_TRUE;
	CK_BBOOL ffalse = CK_FALSE;
	CK_KEY_TYPE ZUCkeyType = CKK_ZUC;
	//加密参数
	unsigned char	ZUCkeyVal_Enc[]={0xe5, 0xbd, 0x3e, 0xa0, 0xeb, 0x55, 0xad, 0xe8, 0x66, 0xc6, 0xac, 0x58, 0xbd, 0x54, 0x30, 0x2a};
	unsigned char	ZUCplain_Enc[128] = {0x14, 0xa8, 0xef, 0x69, 0x3d, 0x67, 0x85, 0x07, 0xbb, 0xe7, 0x27, 0x0a, 0x7f, 0x67, 0xff, 0x50, 0x06, 0xc3, 0x52, 0x5b, 0x98, 0x07, 0xe4, 0x67, 0xc4, 0xe5, 0x60, 0x00, 0xba, 0x33, 0x8f, 0x5d, 0x42, 0x95, 0x59, 0x03, 0x67, 0x51, 0x82, 0x22, 0x46, 0xc8, 0x0d, 0x3b, 0x38, 0xf0, 0x7f, 0x4b, 0xe2, 0xd8, 0xff, 0x58, 0x05, 0xf5, 0x13, 0x22, 0x29, 0xbd, 0xe9, 0x3b, 0xbb, 0xdc, 0xaf, 0x38, \
	 		0x2b, 0xf1, 0xee, 0x97, 0x2f, 0xbf, 0x99, 0x77, 0xba, 0xda, 0x89, 0x45, 0x84, 0x7a, 0x2a, 0x6c, 0x9a, 0xd3, 0x4a, 0x66, 0x75, 0x54, 0xe0, 0x4d, 0x1f, 0x7f, 0xa2, 0xc3, 0x32, 0x41, 0xbd, 0x8f, 0x01, 0xba, 0x22, 0x0d, 0x14, 0xa8, 0xef, 0x69, 0x3d, 0x67, 0x85, 0x07, 0xbb, 0xe7, 0x27, 0x0a, 0x7f, 0x67, 0xff, 0x50, 0x06, 0xc3, 0x52, 0x5b, 0x98, 0x07, 0xe4, 0x67, 0xc4, 0xe5, 0x60, 0x00};
	unsigned char	ZUCcipher_Enc[128] = {0x13, 0x1d, 0x43, 0xe0, 0xde, 0xa1, 0xbe, 0x5c, 0x5a, 0x1b, 0xfd, 0x97, 0x1d, 0x85, 0x2c, 0xbf, 0x71, 0x2d, 0x7b, 0x4f, 0x57, 0x96, 0x1f, 0xea, 0x32, 0x08, 0xaf, 0xa8, 0xbc, 0xa4, 0x33, 0xf4, 0x56, 0xad, 0x09, 0xc7, 0x41, 0x7e, 0x58, 0xbc, 0x69, 0xcf, 0x88, 0x66, 0xd1, 0x35, 0x3f, 0x74, 0x86, 0x5e, 0x80, 0x78, 0x1d, 0x20, 0x2d, 0xfb, 0x3e, 0xcf, 0xf7, 0xfc, 0xbc, 0x3b, 0x19, 0x0f, \
	 		0xe8, 0x2a, 0x20, 0x4e, 0xd0, 0xe3, 0x50, 0xfc, 0x0f, 0x6f, 0x26, 0x13, 0xb2, 0xf2, 0xbc, 0xa6, 0xdf, 0x5a, 0x47, 0x3a, 0x57, 0xa4, 0xa0, 0x0d, 0x98, 0x5e, 0xba, 0xd8, 0x80, 0xd6, 0xf2, 0x38, 0x64, 0xa0, 0x7b, 0x01, 0x9b, 0x48, 0xac, 0xd1, 0xfe, 0xf3, 0x01, 0x1f, 0x5e, 0x22, 0xd2, 0x97, 0x75, 0xcc, 0x94, 0xc2, 0xca, 0x6f, 0xb0, 0x9c, 0x2d, 0x86, 0xd6, 0xd0, 0x18, 0x3c, 0x24, 0x34};	
	unsigned char	ZUCiv_Enc[] = {0x00, 0x05, 0x68, 0x23, 0x38};

	CK_ATTRIBUTE ZUCkeyTemplate_Enc[] = 
	{
		{CKA_CLASS, &keyClass, sizeof(keyClass)},
		{CKA_TOKEN, &ffalse, sizeof(ffalse)},
		{CKA_KEY_TYPE, &ZUCkeyType, sizeof(CK_KEY_TYPE)},
		{CKA_ENCRYPT, &ttrue, sizeof(ttrue)},
		{CKA_VALUE,ZUCkeyVal_Enc,sizeof(ZUCkeyVal_Enc)}
	};
	CK_MECHANISM ZUCmechanism_Enc = {CKM_ZUC_CALC, ZUCiv_Enc, sizeof(ZUCiv_Enc)};
	CK_OBJECT_HANDLE hKey_Enc = NULL_PTR;

	//解密参数
	unsigned char	ZUCkeyVal_Dec[]={0xe5, 0xbd, 0x3e, 0xa0, 0xeb, 0x55, 0xad, 0xe8, 0x66, 0xc6, 0xac, 0x58, 0xbd, 0x54, 0x30, 0x2a};
	unsigned char	ZUCplain_Dec[128] = {0x14, 0xa8, 0xef, 0x69, 0x3d, 0x67, 0x85, 0x07, 0xbb, 0xe7, 0x27, 0x0a, 0x7f, 0x67, 0xff, 0x50, 0x06, 0xc3, 0x52, 0x5b, 0x98, 0x07, 0xe4, 0x67, 0xc4, 0xe5, 0x60, 0x00, 0xba, 0x33, 0x8f, 0x5d, 0x42, 0x95, 0x59, 0x03, 0x67, 0x51, 0x82, 0x22, 0x46, 0xc8, 0x0d, 0x3b, 0x38, 0xf0, 0x7f, 0x4b, 0xe2, 0xd8, 0xff, 0x58, 0x05, 0xf5, 0x13, 0x22, 0x29, 0xbd, 0xe9, 0x3b, 0xbb, 0xdc, 0xaf, 0x38, \
	 		0x2b, 0xf1, 0xee, 0x97, 0x2f, 0xbf, 0x99, 0x77, 0xba, 0xda, 0x89, 0x45, 0x84, 0x7a, 0x2a, 0x6c, 0x9a, 0xd3, 0x4a, 0x66, 0x75, 0x54, 0xe0, 0x4d, 0x1f, 0x7f, 0xa2, 0xc3, 0x32, 0x41, 0xbd, 0x8f, 0x01, 0xba, 0x22, 0x0d, 0x14, 0xa8, 0xef, 0x69, 0x3d, 0x67, 0x85, 0x07, 0xbb, 0xe7, 0x27, 0x0a, 0x7f, 0x67, 0xff, 0x50, 0x06, 0xc3, 0x52, 0x5b, 0x98, 0x07, 0xe4, 0x67, 0xc4, 0xe5, 0x60, 0x00};
	unsigned char	ZUCcipher_Dec[128] = {0x13, 0x1d, 0x43, 0xe0, 0xde, 0xa1, 0xbe, 0x5c, 0x5a, 0x1b, 0xfd, 0x97, 0x1d, 0x85, 0x2c, 0xbf, 0x71, 0x2d, 0x7b, 0x4f, 0x57, 0x96, 0x1f, 0xea, 0x32, 0x08, 0xaf, 0xa8, 0xbc, 0xa4, 0x33, 0xf4, 0x56, 0xad, 0x09, 0xc7, 0x41, 0x7e, 0x58, 0xbc, 0x69, 0xcf, 0x88, 0x66, 0xd1, 0x35, 0x3f, 0x74, 0x86, 0x5e, 0x80, 0x78, 0x1d, 0x20, 0x2d, 0xfb, 0x3e, 0xcf, 0xf7, 0xfc, 0xbc, 0x3b, 0x19, 0x0f, \
			0xe8, 0x2a, 0x20, 0x4e, 0xd0, 0xe3, 0x50, 0xfc, 0x0f, 0x6f, 0x26, 0x13, 0xb2, 0xf2, 0xbc, 0xa6, 0xdf, 0x5a, 0x47, 0x3a, 0x57, 0xa4, 0xa0, 0x0d, 0x98, 0x5e, 0xba, 0xd8, 0x80, 0xd6, 0xf2, 0x38, 0x64, 0xa0, 0x7b, 0x01, 0x9b, 0x48, 0xac, 0xd1, 0xfe, 0xf3, 0x01, 0x1f, 0x5e, 0x22, 0xd2, 0x97, 0x75, 0xcc, 0x94, 0xc2, 0xca, 0x6f, 0xb0, 0x9c, 0x2d, 0x86, 0xd6, 0xd0, 0x18, 0x3c, 0x24, 0x34};

	unsigned char	ZUCiv_Dec[]={0x00, 0x05, 0x68, 0x23, 0x38};

	CK_ATTRIBUTE ZUCkeyTemplate_Dec[] = 
	{
		{CKA_CLASS, &keyClass, sizeof(keyClass)},
		{CKA_TOKEN, &ffalse, sizeof(ffalse)},
		{CKA_KEY_TYPE, &ZUCkeyType, sizeof(CK_KEY_TYPE)},
		{CKA_DECRYPT, &ttrue, sizeof(ttrue)},
		{CKA_VALUE,ZUCkeyVal_Dec,sizeof(ZUCkeyVal_Dec)}
	};
	CK_MECHANISM ZUCmechanism_Dec = {CKM_ZUC_CALC, ZUCiv_Dec, sizeof(ZUCiv_Dec)};
	CK_OBJECT_HANDLE hKey_Dec = NULL_PTR;

	CK_BYTE indata[256] = {0};
	CK_ULONG indatalen=sizeof(indata);
	CK_BYTE outdata[256] = {0};
	CK_ULONG outdatalen=sizeof(outdata);

	CK_BYTE indata1[256] = {0};
	CK_ULONG indatalen1=sizeof(indata1);
	CK_BYTE outdata1[256] = {0};
	CK_ULONG outdatalen1=sizeof(outdata1);

	unsigned int i = 0,j=0;
	int length=0;
	UtilscTime ttc1={0, 0},ttc2={0,0},ttc3={0,0},ttc4={0,0},ttc5={0,0};
	unsigned long long t3 = 0;
	unsigned long long t4 = 0;
	int count = 0;

	//ENTER_LEAVE_FUNCTION(Testresult[9],&length,xTestZUCPerformance);

	//对称加密初始化
	hKey_Enc = NULL_PTR;
	rv = pC_CreateObject(hSession, ZUCkeyTemplate_Enc, sizeof(ZUCkeyTemplate_Enc)/sizeof(CK_ATTRIBUTE), &hKey_Enc);
	//RV_NOT_OK_RETURN_FALSE(Testresult[9],&length,pC_CreateObject_Enc,rv);

	rv = (*pC_EncryptInit)(hSession, &ZUCmechanism_Enc, hKey_Enc);
	//RV_NOT_OK_RETURN_FALSE(Testresult[9],&length,pC_EncryptInit,rv);

	//对称解密初始化
	hKey_Dec = NULL_PTR;
	rv = pC_CreateObject(hSession, ZUCkeyTemplate_Dec, sizeof(ZUCkeyTemplate_Dec)/sizeof(CK_ATTRIBUTE), &hKey_Dec);
	//RV_NOT_OK_RETURN_FALSE(Testresult[9],&length,pC_CreateObject_Dec,rv);

	rv = (*pC_DecryptInit)(hSession, &ZUCmechanism_Dec, hKey_Dec);
	//RV_NOT_OK_RETURN_FALSE(Testresult[9],&length,pC_DecryptInit,rv);

	printf("Datalen=%d.\n",datalen);
	length += sprintf(Testresult[9]+length ,"Datalen=%d.<br>",datalen);

	FILE *fp;

	fp=fopen(pcZucFile,"a");
	if (!fp)
	{
		printf("ZUC test failed, fopen fail.");
		return FALSE;
	} 

	for (i=0; i<loopTime; i++)
	{
		BUFFER_REFRESH_ZERO(indata,indatalen,outdata,outdatalen);
		BUFFER_REFRESH_ZERO(indata1,indatalen1,outdata1,outdatalen1);

		//将IV拼接到明文之前
		memcpy(indata, ZUCiv_Enc, sizeof(ZUCiv_Enc));
		memcpy(indata+sizeof(ZUCiv_Enc), ZUCplain_Enc, datalen);
		indatalen = sizeof(ZUCiv_Enc) + datalen;

		/*******************加密过程**********************/
		Utilsgettime(&ttc1);
		rv = (*pC_EncryptUpdate)(hSession, indata, indatalen, outdata, &outdatalen);
	//	RV_NOT_OK_RETURN_FALSE(Testresult[9],&length,pC_EncryptUpdate,rv);
		Utilsgettime(&ttc2);
		UtilsTimeSubstracted(&ttc2,&ttc1);
		UtilsTimeAdded(&ttc3,&ttc2);
		//Utilsprint(&ttc2,"Encrypt", 1);
		//tt2.printn("ZUC Encrypt", i);

		//将IV拼接到密文之前
		memcpy(indata1, ZUCiv_Dec, sizeof(ZUCiv_Dec));
		memcpy(indata1+sizeof(ZUCiv_Dec), outdata, outdatalen);
		indatalen1 = sizeof(ZUCiv_Dec) + outdatalen;

		/******************解密过程***********************/
		Utilsgettime(&ttc1);
		rv = (*pC_DecryptUpdate)(hSession, indata1, indatalen1, outdata1, &outdatalen1);
		//RV_NOT_OK_RETURN_FALSE(Testresult[9],&length,pC_DecryptUpdate,rv);
		Utilsgettime(&ttc5);
		UtilsTimeSubstracted(&ttc5,&ttc1);
		//Utilsprint(&ttc5,"Decrypt", 1);
		UtilsTimeAdded(&ttc4,&ttc5);

		if (((ttc2).usec + (ttc5).usec) /1000.0f > threshold)
		{
			count++;
		}
		//tt2.printn("ZUC Decrypt", i);

		if ((outdatalen1 != datalen) || (memcmp(outdata1, ZUCplain_Enc, outdatalen1)))
		{
			printf("Error: ZUCPerformance.\n");
			length += sprintf(Testresult[9] + length, "%s", "Error: ZUCPerformance.<br>");
			bRtn = false;
			goto END;
		}
		srand( (unsigned)time( NULL ) );//随机数初始化
		//生成随机数明文	
		RandomGenerate(ZUCplain_Enc,datalen);
		//生成随机数初始向量
		RandomGenerate(ZUCiv_Enc,5);
		memcpy(ZUCiv_Dec,ZUCiv_Enc,5);
	}
	rv = (*pC_EncryptFinal)(hSession, outdata, &outdatalen);
	//RV_NOT_OK_RETURN_FALSE(Testresult[9],&length,pC_EncryptFinal,rv);

	rv = (*pC_DecryptFinal)(hSession, outdata1, &outdatalen1);
	//RV_NOT_OK_RETURN_FALSE(Testresult[9],&length,pC_DecryptFinal,rv);

	rv = (*pC_DestroyObject)(hSession, hKey_Enc);
	//RV_NOT_OK_RETURN_FALSE(Testresult[9],&length,pC_DestroyObject1,rv);

	rv = (*pC_DestroyObject)(hSession, hKey_Dec);
	//RV_NOT_OK_RETURN_FALSE(Testresult[9],&length,pC_DestroyObject2,rv);

	//Utilsprint(&ttc3,"****Encrypt", loopTime);
	//Utilsprint(&ttc4,"****Dencrypt", loopTime);

	t3 = Utilsgetuseconds(&ttc3);
	t4 = Utilsgetuseconds(&ttc4);
	//printf("%.3lf\n",t3/loopTime/1000.0f);
	//printf("%.3lf\n",t4/loopTime/1000.0f);

	sprintf(strtemp, "%.3lf ms", t3/loopTime/1000.0f + t4/loopTime/1000.0f);
	fputs(strtemp, fp);
	fputs("\t", fp);
	sprintf(strtemp, "%d times", count);
	fputs(strtemp, fp);
	fputs("\t", fp);
	fclose(fp);




	bRtn = true;	
END:
	//ENTER_LEAVE_FUNCTION(Testresult[9],&length,xTestZUCPerformance);
	return bRtn;
}


bool Test_SetTransmitDelay()
{
	const char* pcZucFile[] ={ "/sdcard/ZUC32.txt", "/sdcard/ZUC64.txt", "/sdcard/ZUC96.txt",  "/sdcard/ZUC128.txt",  "/sdcard/ZUC141.txt"};
	int i = 0;
	int loopTime = 100;
	bool xnRtn = true;
	int nDelay01, nDelay02;
	char strtemp[256];
	int datalen22[] = {32, 64, 96, 128, 141};
	int threshold[] = {11, 12, 12 , 14, 18};



	printf("ENTER SetTransmitDelay TEST!\n");


			for(i = 0; i <= 4; i +=4)
			{

				
				for(nDelay01 = 700; nDelay01 <= 2500; nDelay01 += 100)
				{
					for(nDelay02 = 100; nDelay02 <= 800; nDelay02 += 100)
					{
					
						FILE *_fp;
						_fp=fopen(pcZucFile[i],"a");
						if (!_fp)
						{
							printf("ZUC test failed, fopen fail.");
							return false;
						} 
						//printf("*********0\n");

						sprintf(strtemp, "%d/%d ms", nDelay01, nDelay02);
						fputs(strtemp, _fp);
						fputs("\t", _fp);
						fclose(_fp);
					//	printf("*********1\n");
						printf("nDelay01=%d,nDelay02=%d\n",nDelay01,nDelay02);


			

						pC_cc_SetTransmitDelay(nDelay01, nDelay02);
						//printf("*********2\n");
						xnRtn = xtest_ZUCPerformance_modify(loopTime, datalen22[i], pcZucFile[i], threshold[i]);
						//printf("*********3\n");

						_fp=fopen(pcZucFile[i],"a");
						if (!_fp)
						{
							printf("ZUC test failed, fopen fail.");
							return false;
						} 

						fputs("\n",_fp); 
						fclose(_fp);



					}
			
				}
			}
			
			printf("The End SetTransmitDelay TEST!\n");
			return true;




}